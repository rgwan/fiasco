From 9c6c0aac62eea361dbce9c55ea4c45d061c233e0 Mon Sep 17 00:00:00 2001
From: Adam Lackorzynski <adam@l4re.org>
Date: Wed, 25 May 2016 00:28:59 +0200
Subject: [PATCH] MIPS: Add virtual platform

This adds a virtual platform to use as a guest in VZ-enabled
virtualization environments.
---
 arch/mips/Kbuild.platforms                         |   1 +
 arch/mips/Kconfig                                  |  26 ++
 arch/mips/configs/mach_virt_defconfig              |  11 +
 .../include/asm/mach-virt/cpu-feature-overrides.h  |  15 +
 arch/mips/include/asm/mach-virt/hypcall.h          |  96 ++++++
 arch/mips/include/asm/timex.h                      |   6 +-
 arch/mips/mach-virt/Makefile                       |   3 +
 arch/mips/mach-virt/Platform                       |   9 +
 arch/mips/mach-virt/early_printk.c                 |  13 +
 arch/mips/mach-virt/irq.c                          |  17 +
 arch/mips/mach-virt/setup.c                        | 101 ++++++
 arch/mips/mm/c-r4k.c                               |   2 +
 drivers/irqchip/irq-mips-gic.c                     | 354 ++++++---------------
 13 files changed, 388 insertions(+), 266 deletions(-)
 create mode 100644 arch/mips/configs/mach_virt_defconfig
 create mode 100644 arch/mips/include/asm/mach-virt/cpu-feature-overrides.h
 create mode 100644 arch/mips/include/asm/mach-virt/hypcall.h
 create mode 100644 arch/mips/mach-virt/Makefile
 create mode 100644 arch/mips/mach-virt/Platform
 create mode 100644 arch/mips/mach-virt/early_printk.c
 create mode 100644 arch/mips/mach-virt/irq.c
 create mode 100644 arch/mips/mach-virt/setup.c

diff --git a/arch/mips/Kbuild.platforms b/arch/mips/Kbuild.platforms
index c5cd63a..5971326 100644
--- a/arch/mips/Kbuild.platforms
+++ b/arch/mips/Kbuild.platforms
@@ -17,6 +17,7 @@ platforms += lantiq
 platforms += lasat
 platforms += loongson32
 platforms += loongson64
+platforms += mach-virt
 platforms += mti-malta
 platforms += mti-sead3
 platforms += netlogic
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 2018c2b..d02a203 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -489,6 +489,32 @@ config MACH_PIC32
 	  Microchip PIC32 is a family of general-purpose 32 bit MIPS core
 	  microcontrollers.
 
+config MIPS_VIRT
+	bool "MIPS virtual platform"
+	select HW_HAS_PCI
+	select BOOT_ELF32
+	select BOOT_RAW
+	select CEVT_R4K
+	select CSRC_R4K
+	select COMMON_CLK
+	select IRQ_MIPS_CPU
+	select DMA_NONCOHERENT
+	select MIPS_GIC
+	select MIPS_CPU_SCACHE
+	select LIBFDT
+	select HW_HAS_PCI
+	select SMP_UP if SMP
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS32_R3_5
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_MIPS_CPS
+	select SYS_SUPPORTS_SMARTMIPS
+	select USE_OF
+
 config MIPS_SEAD3
 	bool "MIPS SEAD3 board"
 	select BOOT_ELF32
diff --git a/arch/mips/configs/mach_virt_defconfig b/arch/mips/configs/mach_virt_defconfig
new file mode 100644
index 0000000..20a0353
--- /dev/null
+++ b/arch/mips/configs/mach_virt_defconfig
@@ -0,0 +1,11 @@
+CONFIG_MIPS_VIRT=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_BLK_DEV_RAM=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_SERIO is not set
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
diff --git a/arch/mips/include/asm/mach-virt/cpu-feature-overrides.h b/arch/mips/include/asm/mach-virt/cpu-feature-overrides.h
new file mode 100644
index 0000000..ded8a1a9
--- /dev/null
+++ b/arch/mips/include/asm/mach-virt/cpu-feature-overrides.h
@@ -0,0 +1,15 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#ifndef __ASM_MACH_VIRT_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_VIRT_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_has_maar		0
+#define cpu_has_htw             0
+#define cpu_has_dc_aliases	1
+#define kernel_uses_llsc	0
+#define cpu_has_nan_legacy	1
+
+#endif /* __ASM_MACH_VIRT_CPU_FEATURE_OVERRIDES_H */
diff --git a/arch/mips/include/asm/mach-virt/hypcall.h b/arch/mips/include/asm/mach-virt/hypcall.h
new file mode 100644
index 0000000..8a7e881
--- /dev/null
+++ b/arch/mips/include/asm/mach-virt/hypcall.h
@@ -0,0 +1,96 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * (C) 2016 Kernkonzept GmbH, Adam Lackorzynski <adam@l4re.org>
+ */
+#pragma once
+
+enum {
+	L4VMM_FUNC_BASE      = 0x160,
+	L4VMM_FUNC_PRINTCHAR = L4VMM_FUNC_BASE + 0,
+};
+
+static inline unsigned long
+l4vmm_hypcall1(unsigned func, unsigned long a0)
+{
+	register unsigned long _a0 asm ("a0") = a0;
+	asm volatile(".set push; .set virt; hypcall %[func]; .set pop"
+	             : "=r" (_a0)
+	             : [func] "K" (func),
+	               "0" (_a0)
+	             : "cc", "memory");
+	return _a0;
+}
+
+static inline unsigned long
+l4vmm_hypcall2(unsigned func, unsigned long a0, unsigned long a1)
+{
+	register unsigned long _a0 asm ("a0") = a0;
+	register unsigned long _a1 asm ("a1") = a1;
+	asm volatile(".set push; .set virt; hypcall %[func]; .set pop"
+	             : "=r" (_a0),
+	               "=r" (_a1)
+	             : [func] "K" (func),
+	               "0" (_a0),
+	               "1" (_a1)
+	             : "cc", "memory");
+	return _a0;
+}
+
+static inline unsigned long
+l4vmm_hypcall2_ret(unsigned func, unsigned long a0, unsigned long *a1)
+{
+	register unsigned long _a0 asm ("a0") = a0;
+	register unsigned long _a1 asm ("a1") = *a1;
+	asm volatile(".set push; .set virt; hypcall %[func]; .set pop"
+	             : "=r" (_a0),
+	               "=r" (_a1)
+	             : [func] "K" (func),
+	               "0" (_a0),
+	               "1" (_a1)
+	             : "cc", "memory");
+	*a1 = _a1;
+	return _a0;
+}
+
+static inline unsigned long
+l4vmm_hypcall3(unsigned func, unsigned long a0, unsigned long a1,
+                              unsigned long a2)
+{
+	register unsigned long _a0 asm ("a0") = a0;
+	register unsigned long _a1 asm ("a1") = a1;
+	register unsigned long _a2 asm ("a2") = a2;
+	asm volatile(".set push; .set virt; hypcall %[func]; .set pop"
+	             : "=r" (_a0),
+	               "=r" (_a1),
+	               "=r" (_a2)
+	             : [func] "K" (func),
+	               "0" (_a0),
+	               "1" (_a1),
+	               "2" (_a2)
+	             : "cc", "memory");
+	return _a0;
+}
+
+static inline unsigned long
+l4vmm_hypcall3_ret(unsigned func, unsigned long a0, unsigned long *a1,
+                                  unsigned long *a2)
+{
+	register unsigned long _a0 asm ("a0") = a0;
+	register unsigned long _a1 asm ("a1") = *a1;
+	register unsigned long _a2 asm ("a2") = *a2;
+	asm volatile(".set push; .set virt; hypcall %[func]; .set pop"
+	             : "=r" (_a0),
+	               "=r" (_a1),
+	               "=r" (_a2)
+	             : [func] "K" (func),
+	               "0" (_a0),
+	               "1" (_a1),
+	               "2" (_a2)
+	             : "cc", "memory");
+	*a1 = _a1;
+	*a2 = _a2;
+	return _a0;
+}
diff --git a/arch/mips/include/asm/timex.h b/arch/mips/include/asm/timex.h
index b05bb70..3222504 100644
--- a/arch/mips/include/asm/timex.h
+++ b/arch/mips/include/asm/timex.h
@@ -71,7 +71,7 @@ static inline int can_use_mips_counter(unsigned int prid)
 
 static inline cycles_t get_cycles(void)
 {
-	if (can_use_mips_counter(read_c0_prid()))
+	if (IS_ENABLED(CONFIG_MIPS_VIRT) || can_use_mips_counter(read_c0_prid()))
 		return read_c0_count();
 	else
 		return 0;	/* no usable counter */
@@ -86,10 +86,10 @@ static inline cycles_t get_cycles(void)
  */
 static inline unsigned long random_get_entropy(void)
 {
-	unsigned int prid = read_c0_prid();
+	unsigned int prid = IS_ENABLED(CONFIG_MIPS_VIRT) ? 0 : read_c0_prid();
 	unsigned int imp = prid & PRID_IMP_MASK;
 
-	if (can_use_mips_counter(prid))
+	if (IS_ENABLED(CONFIG_MIPS_VIRT) || can_use_mips_counter(prid))
 		return read_c0_count();
 	else if (likely(imp != PRID_IMP_R6000 && imp != PRID_IMP_R6000A))
 		return read_c0_random();
diff --git a/arch/mips/mach-virt/Makefile b/arch/mips/mach-virt/Makefile
new file mode 100644
index 0000000..4ae5b28
--- /dev/null
+++ b/arch/mips/mach-virt/Makefile
@@ -0,0 +1,3 @@
+obj-y                        += setup.o irq.o
+
+obj-$(CONFIG_EARLY_PRINTK)   += early_printk.o
diff --git a/arch/mips/mach-virt/Platform b/arch/mips/mach-virt/Platform
new file mode 100644
index 0000000..52ddca7
--- /dev/null
+++ b/arch/mips/mach-virt/Platform
@@ -0,0 +1,9 @@
+#
+# Virtual platform.
+#
+platform-$(CONFIG_MIPS_VIRT)	+= mach-virt/
+cflags-$(CONFIG_MIPS_VIRT)	+= -I$(srctree)/arch/mips/include/asm/mach-virt
+
+load-$(CONFIG_MIPS_VIRT)	+= 0xffffffff80100000
+
+all-$(CONFIG_MIPS_VIRT)		:= $(COMPRESSION_FNAME).bin
diff --git a/arch/mips/mach-virt/early_printk.c b/arch/mips/mach-virt/early_printk.c
new file mode 100644
index 0000000..591ed45
--- /dev/null
+++ b/arch/mips/mach-virt/early_printk.c
@@ -0,0 +1,13 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2016 Kernkonzept GmbH
+ */
+#include <asm/mach-virt/hypcall.h>
+
+void prom_putchar(char c)
+{
+	l4vmm_hypcall1(L4VMM_FUNC_PRINTCHAR, c);
+}
diff --git a/arch/mips/mach-virt/irq.c b/arch/mips/mach-virt/irq.c
new file mode 100644
index 0000000..8a4c9ad
--- /dev/null
+++ b/arch/mips/mach-virt/irq.c
@@ -0,0 +1,17 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2016 Kernkonzept GmbH
+ */
+
+#include <linux/init.h>
+#include <linux/irqchip.h>
+
+#include <asm/irq.h>
+
+void __init arch_init_irq(void)
+{
+	irqchip_init();
+}
diff --git a/arch/mips/mach-virt/setup.c b/arch/mips/mach-virt/setup.c
new file mode 100644
index 0000000..e570b10
--- /dev/null
+++ b/arch/mips/mach-virt/setup.c
@@ -0,0 +1,101 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2016 Kernkonzept GmbH
+ */
+
+#include <linux/init.h>
+#include <linux/initrd.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_platform.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+
+#include <asm/bootinfo.h>
+#include <asm/cpu-features.h>
+#include <asm/irq_cpu.h>
+#include <asm/prom.h>
+#include <asm/time.h>
+
+const char *get_system_type(void)
+{
+	return "MIPS Virtual Platform";
+}
+
+static void __init init_mips_cpu_timer(void)
+{
+	struct device_node *np;
+	u32 freq;
+
+	mips_hpt_frequency = 0;
+
+	/* The timer frequency must be defined in the device tree.
+	   If the definition is missing, we assume that the timer should
+	   not be used.
+	*/
+	np = of_find_node_by_name(NULL, "cpus");
+	if (np && of_property_read_u32(np, "mips-hpt-frequency", &freq) >= 0) {
+		mips_hpt_frequency = freq;
+
+		printk("CPU frequency %d.%02d MHz\n", freq/1000000,
+		       (freq%1000000)*100/1000000);
+	} else
+		pr_warn("MIPS CPU core timer not used. %p, %u\n", np, freq);
+
+	of_node_put(np);
+}
+
+void __init plat_time_init(void)
+{
+	init_mips_cpu_timer();
+}
+
+void __init prom_init(void)
+{
+	int i;
+	int argc = fw_arg0;
+	char **argv = (char **)fw_arg1;
+
+	for (i = 0; i < argc; i++) {
+		strlcat(arcs_cmdline, argv[i], COMMAND_LINE_SIZE);
+		if (i < argc - 1)
+			strlcat(arcs_cmdline, " ", COMMAND_LINE_SIZE);
+	}
+
+	printk("DT at address %p\n", (void *)fw_arg3);
+	__dt_setup_arch((void *)fw_arg3);
+}
+
+void __init plat_mem_setup(void)
+{
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start)
+		initrd_start = (unsigned long)__va(initrd_start);
+	if (initrd_end)
+		initrd_end = (unsigned long)__va(initrd_end);
+#endif
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void __init device_tree_init(void)
+{
+	unflatten_and_copy_device_tree();
+}
+
+static int __init publish_devices(void)
+{
+	if (!of_have_populated_dt())
+		return 0;
+
+	if (of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL))
+		panic("Failed to populate DT");
+
+	return 0;
+}
+device_initcall(publish_devices);
diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c
index caac3d7..0d4d5a4 100644
--- a/arch/mips/mm/c-r4k.c
+++ b/arch/mips/mm/c-r4k.c
@@ -1506,9 +1506,11 @@ static void setup_scache(void)
 				       way_string[c->scache.ways], c->scache.linesz);
 			}
 #else
+#ifndef CONFIG_MIPS_VIRT
 			if (!(c->scache.flags & MIPS_CACHE_NOT_PRESENT))
 				panic("Dunno how to handle MIPS32 / MIPS64 second level cache");
 #endif
+#endif
 			return;
 		}
 		sc_present = 0;
diff --git a/drivers/irqchip/irq-mips-gic.c b/drivers/irqchip/irq-mips-gic.c
index 4dffccf..9e17ef2 100644
--- a/drivers/irqchip/irq-mips-gic.c
+++ b/drivers/irqchip/irq-mips-gic.c
@@ -29,32 +29,16 @@ struct gic_pcpu_mask {
 	DECLARE_BITMAP(pcpu_mask, GIC_MAX_INTRS);
 };
 
-struct gic_irq_spec {
-	enum {
-		GIC_DEVICE,
-		GIC_IPI
-	} type;
-
-	union {
-		struct cpumask *ipimask;
-		unsigned int hwirq;
-	};
-};
-
 static unsigned long __gic_base_addr;
-
 static void __iomem *gic_base;
 static struct gic_pcpu_mask pcpu_masks[NR_CPUS];
 static DEFINE_SPINLOCK(gic_lock);
 static struct irq_domain *gic_irq_domain;
-static struct irq_domain *gic_dev_domain;
-static struct irq_domain *gic_ipi_domain;
 static int gic_shared_intrs;
 static int gic_vpes;
 static unsigned int gic_cpu_pin;
 static unsigned int timer_cpu_pin;
 static struct irq_chip gic_level_irq_controller, gic_edge_irq_controller;
-DECLARE_BITMAP(ipi_resrv, GIC_MAX_INTRS);
 
 static void __gic_irq_dispatch(void);
 
@@ -280,11 +264,9 @@ static void gic_bind_eic_interrupt(int irq, int set)
 		  GIC_VPE_EIC_SS(irq), set);
 }
 
-static void gic_send_ipi(struct irq_data *d, unsigned int cpu)
+void gic_send_ipi(unsigned int intr)
 {
-	irq_hw_number_t hwirq = GIC_HWIRQ_TO_SHARED(irqd_to_hwirq(d));
-
-	gic_write(GIC_REG(SHARED, GIC_SH_WEDGE), GIC_SH_WEDGE_SET(hwirq));
+	gic_write(GIC_REG(SHARED, GIC_SH_WEDGE), GIC_SH_WEDGE_SET(intr));
 }
 
 int gic_get_c0_compare_int(void)
@@ -467,7 +449,7 @@ static int gic_set_affinity(struct irq_data *d, const struct cpumask *cpumask,
 	gic_map_to_vpe(irq, mips_cm_vp_id(cpumask_first(&tmp)));
 
 	/* Update the pcpu_masks */
-	for (i = 0; i < min(gic_vpes, NR_CPUS); i++)
+	for (i = 0; i < NR_CPUS; i++)
 		clear_bit(irq, pcpu_masks[i].pcpu_mask);
 	set_bit(irq, pcpu_masks[cpumask_first(&tmp)].pcpu_mask);
 
@@ -497,7 +479,6 @@ static struct irq_chip gic_edge_irq_controller = {
 #ifdef CONFIG_SMP
 	.irq_set_affinity	=	gic_set_affinity,
 #endif
-	.ipi_send_single	=	gic_send_ipi,
 };
 
 static void gic_handle_local_int(bool chained)
@@ -591,6 +572,83 @@ static void gic_irq_dispatch(struct irq_desc *desc)
 	gic_handle_shared_int(true);
 }
 
+#ifdef CONFIG_MIPS_GIC_IPI
+static int gic_resched_int_base;
+static int gic_call_int_base;
+
+unsigned int plat_ipi_resched_int_xlate(unsigned int cpu)
+{
+	return gic_resched_int_base + cpu;
+}
+
+unsigned int plat_ipi_call_int_xlate(unsigned int cpu)
+{
+	return gic_call_int_base + cpu;
+}
+
+static irqreturn_t ipi_resched_interrupt(int irq, void *dev_id)
+{
+	scheduler_ipi();
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ipi_call_interrupt(int irq, void *dev_id)
+{
+	generic_smp_call_function_interrupt();
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction irq_resched = {
+	.handler	= ipi_resched_interrupt,
+	.flags		= IRQF_PERCPU,
+	.name		= "IPI resched"
+};
+
+static struct irqaction irq_call = {
+	.handler	= ipi_call_interrupt,
+	.flags		= IRQF_PERCPU,
+	.name		= "IPI call"
+};
+
+static __init void gic_ipi_init_one(unsigned int intr, int cpu,
+				    struct irqaction *action)
+{
+	int virq = irq_create_mapping(gic_irq_domain,
+				      GIC_SHARED_TO_HWIRQ(intr));
+	int i;
+
+	gic_map_to_vpe(intr, mips_cm_vp_id(cpu));
+	for (i = 0; i < NR_CPUS; i++)
+		clear_bit(intr, pcpu_masks[i].pcpu_mask);
+	set_bit(intr, pcpu_masks[cpu].pcpu_mask);
+
+	irq_set_irq_type(virq, IRQ_TYPE_EDGE_RISING);
+
+	irq_set_handler(virq, handle_percpu_irq);
+	setup_irq(virq, action);
+}
+
+static __init void gic_ipi_init(void)
+{
+	int i;
+
+	/* Use last 2 * NR_CPUS interrupts as IPIs */
+	gic_resched_int_base = gic_shared_intrs - nr_cpu_ids;
+	gic_call_int_base = gic_resched_int_base - nr_cpu_ids;
+
+	for (i = 0; i < nr_cpu_ids; i++) {
+		gic_ipi_init_one(gic_call_int_base + i, i, &irq_call);
+		gic_ipi_init_one(gic_resched_int_base + i, i, &irq_resched);
+	}
+}
+#else
+static inline void gic_ipi_init(void)
+{
+}
+#endif
+
 static void __init gic_basic_init(void)
 {
 	unsigned int i;
@@ -695,21 +753,19 @@ static int gic_local_irq_domain_map(struct irq_domain *d, unsigned int virq,
 }
 
 static int gic_shared_irq_domain_map(struct irq_domain *d, unsigned int virq,
-				     irq_hw_number_t hw, unsigned int vpe)
+				     irq_hw_number_t hw)
 {
 	int intr = GIC_HWIRQ_TO_SHARED(hw);
 	unsigned long flags;
-	int i;
 
 	irq_set_chip_and_handler(virq, &gic_level_irq_controller,
 				 handle_level_irq);
 
 	spin_lock_irqsave(&gic_lock, flags);
 	gic_map_to_pin(intr, gic_cpu_pin);
-	gic_map_to_vpe(intr, vpe);
-	for (i = 0; i < min(gic_vpes, NR_CPUS); i++)
-		clear_bit(intr, pcpu_masks[i].pcpu_mask);
-	set_bit(intr, pcpu_masks[vpe].pcpu_mask);
+	/* Map to VPE 0 by default */
+	gic_map_to_vpe(intr, 0);
+	set_bit(intr, pcpu_masks[0].pcpu_mask);
 	spin_unlock_irqrestore(&gic_lock, flags);
 
 	return 0;
@@ -720,93 +776,10 @@ static int gic_irq_domain_map(struct irq_domain *d, unsigned int virq,
 {
 	if (GIC_HWIRQ_TO_LOCAL(hw) < GIC_NUM_LOCAL_INTRS)
 		return gic_local_irq_domain_map(d, virq, hw);
-	return gic_shared_irq_domain_map(d, virq, hw, 0);
+	return gic_shared_irq_domain_map(d, virq, hw);
 }
 
-static int gic_irq_domain_alloc(struct irq_domain *d, unsigned int virq,
-				unsigned int nr_irqs, void *arg)
-{
-	struct gic_irq_spec *spec = arg;
-	irq_hw_number_t hwirq, base_hwirq;
-	int cpu, ret, i;
-
-	if (spec->type == GIC_DEVICE) {
-		/* verify that it doesn't conflict with an IPI irq */
-		if (test_bit(spec->hwirq, ipi_resrv))
-			return -EBUSY;
-	} else {
-		base_hwirq = find_first_bit(ipi_resrv, gic_shared_intrs);
-		if (base_hwirq == gic_shared_intrs) {
-			return -ENOMEM;
-		}
-
-		/* check that we have enough space */
-		for (i = base_hwirq; i < nr_irqs; i++) {
-			if (!test_bit(i, ipi_resrv))
-				return -EBUSY;
-		}
-		bitmap_clear(ipi_resrv, base_hwirq, nr_irqs);
-
-		/* map the hwirq for each cpu consecutively */
-		i = 0;
-		for_each_cpu(cpu, spec->ipimask) {
-			hwirq = GIC_SHARED_TO_HWIRQ(base_hwirq + i);
-
-			ret = irq_domain_set_hwirq_and_chip(d, virq + i, hwirq,
-							    &gic_edge_irq_controller,
-							    NULL);
-			if (ret)
-				goto error;
-
-			ret = gic_shared_irq_domain_map(d, virq + i, hwirq, cpu);
-			if (ret)
-				goto error;
-
-			i++;
-		}
-
-		/*
-		 * tell the parent about the base hwirq we allocated so it can
-		 * set its own domain data
-		 */
-		spec->hwirq = base_hwirq;
-	}
-
-	return 0;
-error:
-	bitmap_set(ipi_resrv, base_hwirq, nr_irqs);
-	return ret;
-}
-
-void gic_irq_domain_free(struct irq_domain *d, unsigned int virq,
-			 unsigned int nr_irqs)
-{
-	irq_hw_number_t base_hwirq;
-	struct irq_data *data;
-
-	data = irq_get_irq_data(virq);
-	if (!data)
-		return;
-
-	base_hwirq = GIC_HWIRQ_TO_SHARED(irqd_to_hwirq(data));
-	bitmap_set(ipi_resrv, base_hwirq, nr_irqs);
-}
-
-int gic_irq_domain_match(struct irq_domain *d, struct device_node *node,
-			 enum irq_domain_bus_token bus_token)
-{
-	/* this domain should'nt be accessed directly */
-	return 0;
-}
-
-static const struct irq_domain_ops gic_irq_domain_ops = {
-	.map = gic_irq_domain_map,
-	.alloc = gic_irq_domain_alloc,
-	.free = gic_irq_domain_free,
-	.match = gic_irq_domain_match,
-};
-
-static int gic_dev_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,
+static int gic_irq_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,
 				const u32 *intspec, unsigned int intsize,
 				irq_hw_number_t *out_hwirq,
 				unsigned int *out_type)
@@ -825,130 +798,9 @@ static int gic_dev_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,
 	return 0;
 }
 
-static int gic_dev_domain_alloc(struct irq_domain *d, unsigned int virq,
-				unsigned int nr_irqs, void *arg)
-{
-	struct irq_fwspec *fwspec = arg;
-	struct gic_irq_spec spec = {
-		.type = GIC_DEVICE,
-		.hwirq = fwspec->param[1],
-	};
-	int i, ret;
-	bool is_shared = fwspec->param[0] == GIC_SHARED;
-
-	if (is_shared) {
-		ret = irq_domain_alloc_irqs_parent(d, virq, nr_irqs, &spec);
-		if (ret)
-			return ret;
-	}
-
-	for (i = 0; i < nr_irqs; i++) {
-		irq_hw_number_t hwirq;
-
-		if (is_shared)
-			hwirq = GIC_SHARED_TO_HWIRQ(spec.hwirq + i);
-		else
-			hwirq = GIC_LOCAL_TO_HWIRQ(spec.hwirq + i);
-
-		ret = irq_domain_set_hwirq_and_chip(d, virq + i,
-						    hwirq,
-						    &gic_level_irq_controller,
-						    NULL);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-void gic_dev_domain_free(struct irq_domain *d, unsigned int virq,
-			 unsigned int nr_irqs)
-{
-	/* no real allocation is done for dev irqs, so no need to free anything */
-	return;
-}
-
-static struct irq_domain_ops gic_dev_domain_ops = {
-	.xlate = gic_dev_domain_xlate,
-	.alloc = gic_dev_domain_alloc,
-	.free = gic_dev_domain_free,
-};
-
-static int gic_ipi_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,
-				const u32 *intspec, unsigned int intsize,
-				irq_hw_number_t *out_hwirq,
-				unsigned int *out_type)
-{
-	/*
-	 * There's nothing to translate here. hwirq is dynamically allocated and
-	 * the irq type is always edge triggered.
-	 * */
-	*out_hwirq = 0;
-	*out_type = IRQ_TYPE_EDGE_RISING;
-
-	return 0;
-}
-
-static int gic_ipi_domain_alloc(struct irq_domain *d, unsigned int virq,
-				unsigned int nr_irqs, void *arg)
-{
-	struct cpumask *ipimask = arg;
-	struct gic_irq_spec spec = {
-		.type = GIC_IPI,
-		.ipimask = ipimask
-	};
-	int ret, i;
-
-	ret = irq_domain_alloc_irqs_parent(d, virq, nr_irqs, &spec);
-	if (ret)
-		return ret;
-
-	/* the parent should have set spec.hwirq to the base_hwirq it allocated */
-	for (i = 0; i < nr_irqs; i++) {
-		ret = irq_domain_set_hwirq_and_chip(d, virq + i,
-						    GIC_SHARED_TO_HWIRQ(spec.hwirq + i),
-						    &gic_edge_irq_controller,
-						    NULL);
-		if (ret)
-			goto error;
-
-		ret = irq_set_irq_type(virq + i, IRQ_TYPE_EDGE_RISING);
-		if (ret)
-			goto error;
-	}
-
-	return 0;
-error:
-	irq_domain_free_irqs_parent(d, virq, nr_irqs);
-	return ret;
-}
-
-void gic_ipi_domain_free(struct irq_domain *d, unsigned int virq,
-			 unsigned int nr_irqs)
-{
-	irq_domain_free_irqs_parent(d, virq, nr_irqs);
-}
-
-int gic_ipi_domain_match(struct irq_domain *d, struct device_node *node,
-			 enum irq_domain_bus_token bus_token)
-{
-	bool is_ipi;
-
-	switch (bus_token) {
-	case DOMAIN_BUS_IPI:
-		is_ipi = d->bus_token == bus_token;
-		return to_of_node(d->fwnode) == node && is_ipi;
-		break;
-	default:
-		return 0;
-	}
-}
-
-static struct irq_domain_ops gic_ipi_domain_ops = {
-	.xlate = gic_ipi_domain_xlate,
-	.alloc = gic_ipi_domain_alloc,
-	.free = gic_ipi_domain_free,
-	.match = gic_ipi_domain_match,
+static const struct irq_domain_ops gic_irq_domain_ops = {
+	.map = gic_irq_domain_map,
+	.xlate = gic_irq_domain_xlate,
 };
 
 static void __init __gic_init(unsigned long gic_base_addr,
@@ -957,7 +809,6 @@ static void __init __gic_init(unsigned long gic_base_addr,
 			      struct device_node *node)
 {
 	unsigned int gicconfig;
-	unsigned int v[2];
 
 	__gic_base_addr = gic_base_addr;
 
@@ -1013,32 +864,9 @@ static void __init __gic_init(unsigned long gic_base_addr,
 	if (!gic_irq_domain)
 		panic("Failed to add GIC IRQ domain");
 
-	gic_dev_domain = irq_domain_add_hierarchy(gic_irq_domain, 0,
-						  GIC_NUM_LOCAL_INTRS + gic_shared_intrs,
-						  node, &gic_dev_domain_ops, NULL);
-	if (!gic_dev_domain)
-		panic("Failed to add GIC DEV domain");
-
-	gic_ipi_domain = irq_domain_add_hierarchy(gic_irq_domain,
-						  IRQ_DOMAIN_FLAG_IPI_PER_CPU,
-						  GIC_NUM_LOCAL_INTRS + gic_shared_intrs,
-						  node, &gic_ipi_domain_ops, NULL);
-	if (!gic_ipi_domain)
-		panic("Failed to add GIC IPI domain");
-
-	gic_ipi_domain->bus_token = DOMAIN_BUS_IPI;
-
-	if (node &&
-	    !of_property_read_u32_array(node, "mti,reserved-ipi-vectors", v, 2)) {
-		bitmap_set(ipi_resrv, v[0], v[1]);
-	} else {
-		/* Make the last 2 * gic_vpes available for IPIs */
-		bitmap_set(ipi_resrv,
-			   gic_shared_intrs - 2 * gic_vpes,
-			   2 * gic_vpes);
-	}
-
 	gic_basic_init();
+
+	gic_ipi_init();
 }
 
 void __init gic_init(unsigned long gic_base_addr,
-- 
2.8.1

