// vi:ft=cpp
/*
 * (c) 2008-2009 Alexander Warg <warg@os.inf.tu-dresden.de>,
 *               Torsten Frenzel <frenzel@os.inf.tu-dresden.de>
 *     economic rights: Technische Universit√§t Dresden (Germany)
 *
 * This file is part of TUD:OS and distributed under the terms of the
 * GNU General Public License 2.
 * Please see the COPYING-GPL-2 file for details.
 *
 * As a special exception, you may use this file as part of a free software
 * library without restriction.  Specifically, if other files instantiate
 * templates or use macros or inline functions from this file, or you compile
 * this file and link it with other files to produce an executable, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU General Public License.  This exception does not however
 * invalidate any other reasons why the executable file might be covered by
 * the GNU General Public License.
 */

#pragma once

#include <l4/sys/vcon>

#include <l4/sys/capability>
#include <l4/cxx/ipc_server>

namespace L4Re { namespace Util {

/**
 * \brief Framebuffer server class.
 * \ingroup api_l4re_util
 */
template< typename SVR >
class Vcon_svr
{
public:
#if 0
  /**
   * \brief Write data to console
   *
   * \param buffer Buffer with the output data.
   * \param size   Size of the buffer.
   *
   * \return Negative error code on error,
   *         <= size bytes written.
   */
  int vcon_write(const char *buffer, unsigned size) = 0;
  
  /**
   * \brief Read data from console
   *
   * \param buffer Buffer for the input data.
   * \param size   Size of the buffer.
   *
   * \return Negative error code on error,
   *         > size if more to read, size bytes are in the buffer,
   *         <= size bytes read
   */
  virtual int vcon_read(char *buffer, unsigned size) = 0;
  
  /**
   * \brief Return status of input stream
   * \return true if end of input is reached
   */
  virtual bool vcon_end() = 0;
#endif
  /**
   * \brief Server dispatch function.
   *
   * \param obj Server object ID to work on.
   * \param ios Input/Output stream.
   *
   * \return error code.
   */
  int dispatch(l4_umword_t obj, L4::Ipc_iostream &ios);

private:
  SVR *__self() { return static_cast<SVR*>(this); }
};

template< typename SVR >
int
Vcon_svr<SVR>::dispatch(l4_umword_t, L4::Ipc_iostream &ios)
{
  l4_msgtag_t tag;
  ios >> tag;

  if (tag.label() != L4_PROTO_LOG)
    return -L4_EBADPROTO;
  
  long size;
  ios >> size;
  if (size == 0)
    {
      unsigned long size = 0;
      const char *buf = 0;
      ios >> L4::ipc_buf_in(buf, size);
      __self()->vcon_write(buf, size);
      return -L4_ENOREPLY;
    }
  else
    {
      // shift down to get real size
      size = size >> 16;
      char buf[size];
      size = __self()->vcon_read(buf, size);
      // don't use stream operators, because we need to set eof bit!
      ios.put(__self()->vcon_end() ? size | 1UL << 31 : size);
      ios.put(buf, size);
      return 0;
    }
}

}}
