// vi:ft=cpp
/*
 * (c) 2010 Adam Lackorzynski <adam@os.inf.tu-dresden.de>,
 *          Alexander Warg <warg@os.inf.tu-dresden.de>
 *     economic rights: Technische Universit√§t Dresden (Germany)
 *
 * This file is part of TUD:OS and distributed under the terms of the
 * GNU General Public License 2.
 * Please see the COPYING-GPL-2 file for details.
 *
 * As a special exception, you may use this file as part of a free software
 * library without restriction.  Specifically, if other files instantiate
 * templates or use macros or inline functions from this file, or you compile
 * this file and link it with other files to produce an executable, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU General Public License.  This exception does not however
 * invalidate any other reasons why the executable file might be covered by
 * the GNU General Public License.
 */
#pragma once

#include <l4/l4re_vfs/vfs.h>

namespace L4Re { namespace Vfs {

/// Reference to the applications L4Re::Vfs::Ops singleton.
extern L4Re::Vfs::Ops *vfs_ops asm ("l4re_env_posix_vfs_ops");

class Mount_tree;

/**
 * \brief Boiler plate class for implementing an open file for L4Re::Vfs.
 *
 * This class may be used as a base class for everything that a POSIX
 * file descriptor may point to.  This are things such as regular files,
 * directories, special device files, streams, pipes, and so on.
 */
class Be_file : public File
{
public:
  // used in close, to unlock all locks of a file (as POSIX says)
  int unlock_all_locks() throw()
  { return 0; }

  // for mmap
  L4::Cap<L4Re::Dataspace> data_space() const throw()
  { return L4::Cap<L4Re::Dataspace>::Invalid; }

  /// Default backend for POSIX read and readv functions.
  ssize_t readv(const struct iovec*, int) throw()
  { return -EINVAL; }

  /// Default backend for POSIX write and writev functions.
  ssize_t writev(const struct iovec*, int) throw()
  { return -EINVAL; }

  /// Default backend for POSIX seek and lseek functions.
  virtual off64_t lseek64(off64_t, int) throw()
  { return -ESPIPE; }

  /// Default backend for the POSIX truncate, ftruncate and similar functions.
  int ftruncate64(off64_t) throw()
  { return -EINVAL; }

  /// Default backend for POSIX fsync.
  int fsync() const throw()
  { return -EINVAL; }

  /// Default backend for POSIX fdatasync.
  int fdatasync() const throw()
  { return -EINVAL; }

  /// Default backend for POSIX ioctl.
  int ioctl(unsigned long, va_list) throw()
  { return -EINVAL; }

  /// Default backend for POSIX chmod and fchmod.
  int fchmod(mode_t) throw()
  { return -EINVAL; }

  /// Default backend for POSIX fcntl subfunctions.
  int get_status_flags() const throw()
  { return 0; }

  /// Default backend for POSIX fcntl subfunctions.
  int set_status_flags(long) throw()
  { return 0; }

  /// Default backend for POSIX fcntl subfunctions.
  int get_lock(struct flock64 *) throw()
  { return -ENOLCK; }

  /// Default backend for POSIX fcntl subfunctions.
  int set_lock(struct flock64 *, bool) throw()
  { return -ENOLCK; }

  /// Default backend for POSIX access and faccessat functions.
  int faccessat(const char *, int, int) throw()
  { return -ENOTDIR; }

  /// Default backend for POSIX utime.
  int utime(const struct utimbuf *) throw()
  { return -EROFS; }

  /// Default backend for POSIX utimes.
  int utimes(const struct utimbuf [2]) throw()
  { return -EROFS; }

  /// Default backend for POSIX mkdir and mkdirat.
  int mkdir(const char *, mode_t) throw()
  { return -ENOTDIR; }

  /// Default backend for POSIX unlink, unlinkat.
  int unlink(const char *) throw()
  { return -ENOTDIR; }

  /// Default backend for POSIX rename, renameat.
  int rename(const char *, const char *) throw()
  { return -ENOTDIR; }

  /// Default backend for POSIX link, linkat.
  int link(const char *, const char *) throw()
  { return -ENOTDIR; }

  /// Default backend for POSIX symlink, symlinkat.
  int symlink(const char *, const char *) throw()
  { return -ENOTDIR; }

  /// Default backend for POSIX rmdir, rmdirat.
  int rmdir(const char *) throw()
  { return -ENOTDIR; }

  /// Default backend for POSIX readlink, readlinkat.
  ssize_t readlink(char *, size_t)
  { return -EINVAL; }

  ssize_t getdents(char *, size_t) throw()
  { return -ENOTDIR; }


  ~Be_file() throw() = 0;

private:
  /// Default backend for POSIX openat, open.
  int get_entry(const char *, int, mode_t, cxx::Ref_ptr<File> *) throw()
  { return -ENOTDIR; }

protected:
  const char *get_mount(const char *path, cxx::Ref_ptr<File> *dir) throw();
};

inline
Be_file::~Be_file() throw() {}

/**
 * \brief Boilerplate class for implementing a L4Re::Vfs::File_system.
 *
 * This class already takes care of registering and unregistering the
 * file system in the global registry and implements the type() method.
 */
class Be_file_system : public File_system
{
private:
  char const *const _fstype;

public:

  /**
   * \brief Create a file-system object for the given \a fstype.
   * \param fstype The type that type() shall return.
   *
   * This constructor takes care of registering the file system
   * in the registry of L4Re::Vfs::vfs_ops.
   */
  explicit Be_file_system(char const *fstype) throw()
  : File_system(), _fstype(fstype)
  {
    vfs_ops->register_file_system(this);
  }

  /**
   * \brief Destroy a file-system object.
   *
   * This destructor takes care of removing this file system
   * from the registry of L4Re::Vfs::vfs_ops.
   */
  ~Be_file_system() throw() 
  {
    vfs_ops->unregister_file_system(this);
  }

  /**
   * \brief Return the file-system type.
   *
   * Returns the file-system type given as \a fstype in the constructor.
   */
  char const *type() const throw() { return _fstype; }
};


}}
